"""Tests for scanner.pr_review_merge helpers."""

import json
from unittest.mock import patch

from rich.console import Console

from securevibes.models.issue import SecurityIssue, Severity
from securevibes.scanner.pr_review_merge import (
    attempts_show_pr_disagreement,
    build_pr_retry_focus_plan,
    build_pr_review_retry_suffix,
    _build_vuln_match_keys,
    _chain_role,
    _entry_quality,
    extract_observed_pr_findings,
    _finding_tokens,
    focus_area_label,
    _has_concrete_chain_structure,
    issues_from_pr_vulns,
    load_pr_vulnerabilities_artifact,
    merge_pr_attempt_findings,
    _normalize_finding_identity,
    _proof_score,
    _same_chain,
    _same_subchain_family,
    should_run_pr_verifier,
    _speculation_penalty,
    _token_similarity,
    dedupe_pr_vulns,
    filter_baseline_vulns,
)


class TestFilterBaselineVulns:
    """Tests for filter_baseline_vulns."""

    def test_excludes_pr_review_entries(self):
        known_vulns = [
            {"threat_id": "PR-001", "title": "Generated by PR review"},
            {"threat_id": "THREAT-1", "source": "pr_review", "title": "PR artifact"},
            {"threat_id": "THREAT-2", "finding_type": "regression", "title": "PR regression"},
            {"threat_id": "THREAT-3", "finding_type": "unknown", "title": "PR unknown"},
            {"threat_id": "THREAT-4", "title": "Baseline vuln"},
        ]
        baseline = filter_baseline_vulns(known_vulns)
        assert baseline == [
            {"threat_id": "THREAT-2", "finding_type": "regression", "title": "PR regression"},
            {"threat_id": "THREAT-3", "finding_type": "unknown", "title": "PR unknown"},
            {"threat_id": "THREAT-4", "title": "Baseline vuln"},
        ]

    def test_empty_list_returns_empty(self):
        assert filter_baseline_vulns([]) == []

    def test_all_pr_entries_returns_empty(self):
        vulns = [
            {"threat_id": "PR-001", "title": "PR entry"},
            {"threat_id": "NEW-001", "title": "New entry"},
            {"source": "pr_review", "title": "Source-tagged"},
        ]
        assert filter_baseline_vulns(vulns) == []

    def test_all_baseline_entries_returned(self):
        vulns = [
            {"threat_id": "THREAT-1", "title": "Baseline 1"},
            {"threat_id": "THREAT-2", "title": "Baseline 2"},
        ]
        baseline = filter_baseline_vulns(vulns)
        assert len(baseline) == 2
        assert baseline == vulns

    def test_non_dict_entries_skipped(self):
        vulns = [
            "not a dict",
            42,
            None,
            {"threat_id": "THREAT-1", "title": "Valid baseline"},
        ]
        baseline = filter_baseline_vulns(vulns)
        assert len(baseline) == 1
        assert baseline[0]["threat_id"] == "THREAT-1"

    def test_new_prefix_excluded(self):
        vulns = [{"threat_id": "NEW-42", "title": "New threat"}]
        assert filter_baseline_vulns(vulns) == []

    def test_prefix_excluded_case_insensitive(self):
        vulns = [
            {"threat_id": "pr-42", "title": "Lowercase PR"},
            {"threat_id": "new-99", "title": "Lowercase NEW"},
            {"threat_id": "THREAT-1", "title": "Baseline"},
        ]
        assert filter_baseline_vulns(vulns) == [{"threat_id": "THREAT-1", "title": "Baseline"}]

    def test_source_filtered_case_insensitive(self):
        vulns = [
            {"threat_id": "THREAT-1", "source": " PR_REVIEW ", "title": "Generated"},
            {"threat_id": "THREAT-2", "title": "Baseline"},
        ]
        assert filter_baseline_vulns(vulns) == [{"threat_id": "THREAT-2", "title": "Baseline"}]

    def test_finding_type_alone_does_not_filter_baseline(self):
        vulns = [
            {"threat_id": "THREAT-1", "finding_type": "REGRESSION", "title": "Baseline"},
            {
                "threat_id": "THREAT-2",
                "source": "pr_review",
                "finding_type": " Unknown ",
                "title": "PR generated",
            },
        ]
        assert filter_baseline_vulns(vulns) == [
            {"threat_id": "THREAT-1", "finding_type": "REGRESSION", "title": "Baseline"}
        ]

    def test_mixed_baseline_and_pr(self):
        vulns = [
            {"threat_id": "THREAT-1", "title": "Baseline"},
            {"threat_id": "PR-10", "title": "PR"},
            {"threat_id": "THREAT-2", "title": "Baseline 2"},
            {"finding_type": "new_threat", "title": "PR threat"},
        ]
        baseline = filter_baseline_vulns(vulns)
        assert len(baseline) == 3
        assert baseline[0]["title"] == "Baseline"
        assert baseline[1]["title"] == "Baseline 2"
        assert baseline[2]["title"] == "PR threat"


class TestNormalizeFindingIdentity:
    """Tests for _normalize_finding_identity."""

    def test_normal_string(self):
        assert _normalize_finding_identity("CommandInjection") == "commandinjection"

    def test_whitespace_stripped(self):
        assert _normalize_finding_identity("  Hello World  ") == "hello world"

    def test_non_string_returns_empty(self):
        assert _normalize_finding_identity(42) == ""
        assert _normalize_finding_identity(None) == ""
        assert _normalize_finding_identity([]) == ""
        assert _normalize_finding_identity({}) == ""

    def test_empty_string(self):
        assert _normalize_finding_identity("") == ""

    def test_already_lowercase(self):
        assert _normalize_finding_identity("already lower") == "already lower"


class TestBuildVulnMatchKeys:
    """Tests for _build_vuln_match_keys."""

    def test_with_path_and_title(self):
        vuln = {"title": "SQLi", "file_path": "src/app.py"}
        keys = _build_vuln_match_keys(vuln)
        assert len(keys) > 0
        # Should include basename key and full path key
        identities = {k[1] for k in keys}
        assert "sqli" in identities

    def test_with_threat_id_and_title(self):
        vuln = {"threat_id": "THREAT-1", "title": "XSS", "file_path": "src/views.py"}
        keys = _build_vuln_match_keys(vuln)
        identities = {k[1] for k in keys}
        assert "threat-1" in identities
        assert "xss" in identities

    def test_without_path(self):
        vuln = {"title": "Issue"}
        keys = _build_vuln_match_keys(vuln)
        # Without file_path, path is empty string
        paths = {k[0] for k in keys}
        assert "" in paths

    def test_no_identities_returns_empty(self):
        vuln = {"file_path": "src/app.py"}
        keys = _build_vuln_match_keys(vuln)
        assert keys == set()

    def test_non_string_identities_returns_empty(self):
        vuln = {"threat_id": 123, "title": None}
        keys = _build_vuln_match_keys(vuln)
        assert keys == set()

    def test_basename_included(self):
        vuln = {"title": "Bug", "file_path": "packages/core/src/handler.py"}
        keys = _build_vuln_match_keys(vuln)
        paths = {k[0] for k in keys}
        assert "handler.py" in paths


class TestIssuesFromPrVulns:
    """Tests for issues_from_pr_vulns."""

    def test_valid_entry(self):
        vulns = [
            {
                "threat_id": "PR-1",
                "title": "SQL Injection",
                "description": "User input unsanitized",
                "severity": "high",
                "file_path": "src/db.py",
                "line_number": 42,
                "code_snippet": "query = f'SELECT * FROM {user_input}'",
                "cwe_id": "CWE-89",
                "recommendation": "Use parameterized queries",
                "finding_type": "new_threat",
                "attack_scenario": "Attacker submits malicious input",
                "evidence": "No input validation found",
            }
        ]
        issues = issues_from_pr_vulns(vulns)
        assert len(issues) == 1
        issue = issues[0]
        assert isinstance(issue, SecurityIssue)
        assert issue.id == "PR-1"
        assert issue.title == "SQL Injection"
        assert issue.severity == Severity.HIGH
        assert issue.file_path == "src/db.py"
        assert issue.line_number == 42
        assert issue.cwe_id == "CWE-89"
        assert issue.finding_type == "new_threat"

    def test_missing_fields_use_defaults(self):
        vulns = [{}]
        issues = issues_from_pr_vulns(vulns)
        assert len(issues) == 1
        issue = issues[0]
        assert issue.id == "UNKNOWN"
        assert issue.title == ""
        assert issue.severity == Severity.MEDIUM
        assert issue.line_number == 0

    def test_invalid_severity_defaults_to_medium(self):
        vulns = [{"severity": "super_critical"}]
        issues = issues_from_pr_vulns(vulns)
        assert issues[0].severity == Severity.MEDIUM

    def test_non_dict_entries_skipped(self):
        vulns = ["not a dict", 42, None, {"title": "Valid"}]
        issues = issues_from_pr_vulns(vulns)
        assert len(issues) == 1
        assert issues[0].title == "Valid"

    def test_invalid_line_number_defaults_to_zero(self):
        vulns = [{"line_number": "not_a_number"}]
        issues = issues_from_pr_vulns(vulns)
        assert issues[0].line_number == 0

    def test_none_line_number_defaults_to_zero(self):
        vulns = [{"line_number": None}]
        issues = issues_from_pr_vulns(vulns)
        assert issues[0].line_number == 0

    def test_empty_list(self):
        assert issues_from_pr_vulns([]) == []

    def test_multiple_entries(self):
        vulns = [
            {"threat_id": "PR-1", "title": "Issue 1"},
            {"threat_id": "PR-2", "title": "Issue 2"},
        ]
        issues = issues_from_pr_vulns(vulns)
        assert len(issues) == 2
        assert issues[0].id == "PR-1"
        assert issues[1].id == "PR-2"


class TestFocusAreaLabel:
    """Tests for focus_area_label."""

    def test_known_command_option(self):
        assert focus_area_label("command_option") == "COMMAND/OPTION INJECTION CHAINS"

    def test_known_path_exfiltration(self):
        assert focus_area_label("path_exfiltration") == "PATH + FILE EXFILTRATION CHAINS"

    def test_known_auth_privileged(self):
        assert focus_area_label("auth_privileged") == "AUTH + PRIVILEGED OPERATION CHAINING"

    def test_unknown_label_returns_input(self):
        assert focus_area_label("something_else") == "something_else"

    def test_empty_string(self):
        assert focus_area_label("") == ""


class TestBuildPrRetryFocusPlan:
    """Tests for build_pr_retry_focus_plan."""

    def test_attempt_count_1_returns_empty(self):
        result = build_pr_retry_focus_plan(
            1,
            command_builder_signals=True,
            path_parser_signals=True,
            auth_privilege_signals=True,
        )
        assert result == []

    def test_attempt_count_0_returns_empty(self):
        result = build_pr_retry_focus_plan(
            0,
            command_builder_signals=True,
            path_parser_signals=True,
            auth_privilege_signals=True,
        )
        assert result == []

    def test_attempt_count_3_with_all_signals(self):
        result = build_pr_retry_focus_plan(
            3,
            command_builder_signals=True,
            path_parser_signals=True,
            auth_privilege_signals=True,
        )
        # 3 attempts => 2 retries
        assert len(result) == 2
        assert result[0] == "command_option"
        assert result[1] == "path_exfiltration"

    def test_attempt_count_3_no_signals(self):
        result = build_pr_retry_focus_plan(
            3,
            command_builder_signals=False,
            path_parser_signals=False,
            auth_privilege_signals=False,
        )
        # Falls back to default order
        assert len(result) == 2
        assert result[0] == "command_option"
        assert result[1] == "path_exfiltration"

    def test_attempt_count_2_with_path_signal_only(self):
        result = build_pr_retry_focus_plan(
            2,
            command_builder_signals=False,
            path_parser_signals=True,
            auth_privilege_signals=False,
        )
        # 2 attempts => 1 retry
        assert len(result) == 1
        assert result[0] == "path_exfiltration"

    def test_wraps_around_with_many_retries(self):
        result = build_pr_retry_focus_plan(
            5,
            command_builder_signals=False,
            path_parser_signals=False,
            auth_privilege_signals=False,
        )
        # 5 attempts => 4 retries, cycles through 3 focus areas
        assert len(result) == 4
        assert result[3] == result[0]  # wraps around


class TestAttemptsShowPrDisagreement:
    """Tests for attempts_show_pr_disagreement."""

    def test_single_attempt_returns_false(self):
        assert attempts_show_pr_disagreement([5]) is False

    def test_empty_list_returns_false(self):
        assert attempts_show_pr_disagreement([]) is False

    def test_all_same_nonzero_returns_false(self):
        assert attempts_show_pr_disagreement([3, 3, 3]) is False

    def test_all_zero_returns_false(self):
        assert attempts_show_pr_disagreement([0, 0, 0]) is False

    def test_some_zero_some_nonzero_returns_true(self):
        assert attempts_show_pr_disagreement([3, 0, 3]) is True

    def test_all_different_nonzero_returns_true(self):
        assert attempts_show_pr_disagreement([1, 2, 3]) is True

    def test_two_attempts_same(self):
        assert attempts_show_pr_disagreement([2, 2]) is False

    def test_two_attempts_different(self):
        assert attempts_show_pr_disagreement([2, 5]) is True

    def test_one_zero_one_nonzero(self):
        assert attempts_show_pr_disagreement([0, 5]) is True


class TestShouldRunPrVerifier:
    """Tests for should_run_pr_verifier."""

    def test_true_when_both_conditions_met(self):
        assert should_run_pr_verifier(has_findings=True, weak_consensus=True) is True

    def test_false_when_no_findings(self):
        assert should_run_pr_verifier(has_findings=False, weak_consensus=True) is False

    def test_false_when_strong_consensus(self):
        assert should_run_pr_verifier(has_findings=True, weak_consensus=False) is False

    def test_false_when_neither(self):
        assert should_run_pr_verifier(has_findings=False, weak_consensus=False) is False


class TestExtractObservedPrFindings:
    """Tests for extract_observed_pr_findings."""

    def test_none_observer_returns_empty(self):
        assert extract_observed_pr_findings(None) == []

    def test_empty_dict_observer_returns_empty(self):
        assert extract_observed_pr_findings({}) == []

    def test_empty_max_content_returns_empty(self):
        assert extract_observed_pr_findings({"max_content": ""}) == []

    def test_whitespace_max_content_returns_empty(self):
        assert extract_observed_pr_findings({"max_content": "   "}) == []

    def test_valid_json_list(self):
        findings = [{"title": "Issue 1"}, {"title": "Issue 2"}]
        observer = {"max_content": json.dumps(findings)}
        result = extract_observed_pr_findings(observer)
        assert len(result) == 2
        assert result[0]["title"] == "Issue 1"

    def test_invalid_json_returns_empty(self):
        assert extract_observed_pr_findings({"max_content": "not json {"}) == []

    def test_non_list_json_returns_empty(self):
        assert extract_observed_pr_findings({"max_content": '{"key": "value"}'}) == []

    def test_non_dict_entries_filtered(self):
        observer = {"max_content": json.dumps([{"title": "Valid"}, "invalid", 42])}
        result = extract_observed_pr_findings(observer)
        assert len(result) == 1
        assert result[0]["title"] == "Valid"

    def test_non_string_max_content_returns_empty(self):
        assert extract_observed_pr_findings({"max_content": 12345}) == []


class TestBuildPrReviewRetrySuffix:
    """Tests for build_pr_review_retry_suffix."""

    def test_basic_retry_contains_attempt_number(self):
        result = build_pr_review_retry_suffix(2)
        assert "FOLLOW-UP ANALYSIS PASS 2" in result

    def test_default_focus_area_attempt_2(self):
        result = build_pr_review_retry_suffix(2)
        # attempt_num==2 defaults to command_option focus
        assert "COMMAND/OPTION INJECTION CHAINS" in result

    def test_default_focus_area_attempt_3(self):
        result = build_pr_review_retry_suffix(3)
        assert "PATH + FILE EXFILTRATION CHAINS" in result

    def test_default_focus_area_attempt_4(self):
        result = build_pr_review_retry_suffix(4)
        assert "AUTH + PRIVILEGED OPERATION CHAINING" in result

    def test_explicit_focus_area_overrides_default(self):
        result = build_pr_review_retry_suffix(2, focus_area="auth_privileged")
        assert "AUTH + PRIVILEGED OPERATION CHAINING" in result
        # Should NOT contain command_option default focus for attempt 2
        assert "FOCUS AREA: COMMAND/OPTION INJECTION CHAINS" not in result

    def test_command_builder_signals_hint(self):
        result = build_pr_review_retry_suffix(2, command_builder_signals=True)
        assert "COMMAND-BUILDER DELTA DETECTED" in result

    def test_path_parser_signals_hint(self):
        result = build_pr_review_retry_suffix(2, path_parser_signals=True)
        assert "PATH-PARSER DELTA DETECTED" in result

    def test_auth_privilege_signals_hint(self):
        result = build_pr_review_retry_suffix(2, auth_privilege_signals=True)
        assert "AUTH/PRIVILEGE DELTA DETECTED" in result

    def test_candidate_summary_included(self):
        result = build_pr_review_retry_suffix(
            2, candidate_summary="Chain 1: option injection in build_cmd"
        )
        assert "Chain 1: option injection in build_cmd" in result
        assert "PRIOR HIGH-IMPACT CHAIN CANDIDATES" in result
        assert "UNRESOLVED HYPOTHESIS DISPOSITION" in result

    def test_empty_candidate_summary_no_hint(self):
        result = build_pr_review_retry_suffix(2, candidate_summary="")
        assert "PRIOR HIGH-IMPACT CHAIN CANDIDATES" not in result

    def test_whitespace_only_candidate_summary_no_hint(self):
        result = build_pr_review_retry_suffix(2, candidate_summary="   ")
        assert "PRIOR HIGH-IMPACT CHAIN CANDIDATES" not in result

    def test_require_candidate_revalidation(self):
        result = build_pr_review_retry_suffix(
            2, candidate_summary="something", require_candidate_revalidation=True
        )
        assert "CORE CHAIN REVALIDATION REQUIREMENT" in result

    def test_revalidation_without_candidate_summary(self):
        result = build_pr_review_retry_suffix(2, require_candidate_revalidation=True)
        # Without candidate_summary, revalidation hint should still appear
        assert "CORE CHAIN REVALIDATION REQUIREMENT" in result


class TestMergePrAttemptFindings:
    """Tests for merge_pr_attempt_findings."""

    def test_empty_input_returns_empty(self):
        result = merge_pr_attempt_findings([])
        assert result == []

    def test_empty_input_populates_merge_stats(self):
        stats = {}
        merge_pr_attempt_findings([], merge_stats=stats)
        assert stats["input_count"] == 0
        assert stats["canonical_count"] == 0
        assert stats["final_count"] == 0
        assert stats["speculative_dropped"] == 0
        assert stats["subchain_collapsed"] == 0
        assert stats["low_support_dropped"] == 0
        assert stats["dropped_as_secondary_chain"] == 0
        assert stats["max_chain_support"] == 0

    def test_single_finding_retained(self):
        finding = {
            "threat_id": "PR-1",
            "title": "Option injection in build_ssh_command via unsanitized host",
            "description": "The host parameter is interpolated into the ssh command without validation",
            "severity": "high",
            "file_path": "src/ssh_client.py",
            "line_number": 42,
            "code_snippet": "cmd = f'ssh {host}'",
            "cwe_id": "CWE-88",
            "finding_type": "new_threat",
            "attack_scenario": "1) Attacker supplies -o ProxyCommand=... as host\n2) ssh executes attacker payload",
            "evidence": "src/ssh_client.py:42 -> ssh exec without -- separator",
        }
        result = merge_pr_attempt_findings([finding])
        assert len(result) >= 1

    def test_duplicate_findings_merged(self):
        """Two findings with same path, same CWE, close line numbers, similar tokens should merge."""
        finding_1 = {
            "threat_id": "PR-1",
            "title": "Option injection in build_ssh_command",
            "description": "Unsanitized host param allows option injection",
            "severity": "high",
            "file_path": "src/ssh_client.py",
            "line_number": 42,
            "cwe_id": "CWE-88",
            "finding_type": "new_threat",
            "attack_scenario": "1) Attacker supplies -o ProxyCommand=... as host\n2) ssh exec",
            "evidence": "src/ssh_client.py:42 -> exec",
        }
        finding_2 = {
            "threat_id": "PR-2",
            "title": "Option injection in build_ssh_command via host param",
            "description": "Unsanitized host parameter enables option injection in ssh",
            "severity": "high",
            "file_path": "src/ssh_client.py",
            "line_number": 43,
            "cwe_id": "CWE-88",
            "finding_type": "new_threat",
            "attack_scenario": "1) Attacker supplies -o ProxyCommand=... as host\n2) ssh exec",
            "evidence": "src/ssh_client.py:42 -> exec flow",
        }
        stats = {}
        result = merge_pr_attempt_findings([finding_1, finding_2], merge_stats=stats)
        # Should merge into one since they are about the same chain
        assert stats["input_count"] == 2
        assert len(result) == 1
        assert result[0]["cwe_id"] == "CWE-88"

    def test_merge_stats_populated(self):
        finding = {
            "threat_id": "PR-1",
            "title": "Test finding",
            "severity": "medium",
            "file_path": "src/app.py",
            "line_number": 10,
            "finding_type": "new_threat",
        }
        stats = {}
        merge_pr_attempt_findings([finding], merge_stats=stats)
        assert "input_count" in stats
        assert stats["input_count"] == 1
        assert "canonical_count" in stats
        assert "final_count" in stats

    def test_non_dict_entries_filtered(self):
        vulns = ["not_a_dict", 42, {"threat_id": "PR-1", "title": "Valid"}]
        result = merge_pr_attempt_findings(vulns)
        # Non-dict entries should be filtered out during normalization
        assert all(isinstance(r, dict) for r in result)

    def test_low_support_dropped_with_chain_counts(self):
        """Findings with low chain support should be dropped when others have high support."""
        high_support_finding = {
            "threat_id": "PR-1",
            "title": "Option injection in build_ssh_command via unsanitized host",
            "description": "Host parameter injection leads to arbitrary option injection",
            "severity": "high",
            "file_path": "src/ssh.py",
            "line_number": 42,
            "cwe_id": "CWE-88",
            "finding_type": "new_threat",
            "attack_scenario": "1) Attacker supplies -o ProxyCommand=payload as host\n2) ssh executes payload",
            "evidence": "src/ssh.py:42 -> ssh exec without -- separator",
        }
        low_support_finding = {
            "threat_id": "PR-2",
            "title": "Missing rate limit on login endpoint",
            "description": "No rate limiting",
            "severity": "medium",
            "file_path": "src/auth.py",
            "line_number": 100,
            "cwe_id": "CWE-307",
            "finding_type": "new_threat",
            "attack_scenario": "1) Attacker brute forces\n2) Auth bypassed",
            "evidence": "src/auth.py:100 -> flow to login handler",
        }
        from securevibes.scanner.chain_analysis import (
            build_chain_family_identity,
            build_chain_identity,
        )

        chain_support = {}
        for identity_fn in (build_chain_family_identity, build_chain_identity):
            key = identity_fn(high_support_finding)
            if key:
                chain_support[key] = 3
            key = identity_fn(low_support_finding)
            if key:
                chain_support[key] = 1

        stats = {}
        merge_pr_attempt_findings(
            [high_support_finding, low_support_finding],
            merge_stats=stats,
            chain_support_counts=chain_support,
            total_attempts=3,
        )
        # The low support finding may be dropped
        assert stats["input_count"] == 2

    def test_max_chain_support_stat(self):
        finding = {
            "threat_id": "PR-1",
            "title": "Test",
            "severity": "high",
            "file_path": "a.py",
            "line_number": 1,
        }
        stats = {}
        chain_support = {"some_chain": 5}
        merge_pr_attempt_findings(
            [finding],
            merge_stats=stats,
            chain_support_counts=chain_support,
            total_attempts=5,
        )
        assert stats["max_chain_support"] == 5

    def test_no_chain_support_counts_stat_zero(self):
        stats = {}
        merge_pr_attempt_findings(
            [{"threat_id": "PR-1", "title": "Test"}],
            merge_stats=stats,
            chain_support_counts=None,
            total_attempts=0,
        )
        assert stats["max_chain_support"] == 0


class TestDedupePrVulns:
    """Tests for dedupe_pr_vulns."""

    def test_marks_unknown_overlap_as_known_vuln(self):
        known_vulns = [
            {
                "threat_id": "THREAT-123",
                "title": "Command injection path",
                "file_path": "src/runner.py",
            }
        ]
        pr_vulns = [
            {
                "threat_id": "PR-999",
                "title": "Command injection path",
                "file_path": "src/runner.py",
                "finding_type": "unknown",
            }
        ]
        deduped = dedupe_pr_vulns(pr_vulns, known_vulns)
        assert len(deduped) == 1
        assert deduped[0]["finding_type"] == "known_vuln"

    def test_no_overlap_no_change(self):
        known_vulns = [
            {"threat_id": "THREAT-1", "title": "XSS in template", "file_path": "src/views.py"}
        ]
        pr_vulns = [
            {
                "threat_id": "PR-1",
                "title": "SQLi in query builder",
                "file_path": "src/db.py",
                "finding_type": "unknown",
            }
        ]
        deduped = dedupe_pr_vulns(pr_vulns, known_vulns)
        assert len(deduped) == 1
        assert deduped[0]["finding_type"] == "unknown"

    def test_non_unknown_finding_type_not_changed(self):
        """If finding_type is already set to something other than 'unknown', it should not be changed."""
        known_vulns = [{"threat_id": "THREAT-1", "title": "Same title", "file_path": "src/app.py"}]
        pr_vulns = [
            {
                "threat_id": "PR-1",
                "title": "Same title",
                "file_path": "src/app.py",
                "finding_type": "new_threat",
            }
        ]
        deduped = dedupe_pr_vulns(pr_vulns, known_vulns)
        assert len(deduped) == 1
        assert deduped[0]["finding_type"] == "new_threat"

    def test_empty_pr_vulns(self):
        deduped = dedupe_pr_vulns([], [{"threat_id": "T-1", "title": "Baseline"}])
        assert deduped == []

    def test_empty_known_vulns(self):
        pr_vulns = [{"threat_id": "PR-1", "title": "Issue", "finding_type": "unknown"}]
        deduped = dedupe_pr_vulns(pr_vulns, [])
        assert len(deduped) == 1
        assert deduped[0]["finding_type"] == "unknown"

    def test_non_dict_known_vulns_skipped(self):
        pr_vulns = [{"threat_id": "PR-1", "title": "Issue", "finding_type": "unknown"}]
        deduped = dedupe_pr_vulns(pr_vulns, ["not_a_dict", 42])
        assert len(deduped) == 1
        assert deduped[0]["finding_type"] == "unknown"

    def test_non_dict_pr_vulns_skipped(self):
        deduped = dedupe_pr_vulns(
            ["not_a_dict", {"threat_id": "PR-1", "title": "Valid"}],
            [{"threat_id": "T-1", "title": "Baseline"}],
        )
        assert len(deduped) == 1

    def test_threat_id_overlap_marks_as_known(self):
        """Overlap by threat_id identity match should mark as known_vuln."""
        known_vulns = [{"threat_id": "THREAT-1", "title": "Some vuln", "file_path": "src/app.py"}]
        pr_vulns = [
            {
                "threat_id": "THREAT-1",
                "title": "Different title",
                "file_path": "src/app.py",
                "finding_type": "unknown",
            }
        ]
        deduped = dedupe_pr_vulns(pr_vulns, known_vulns)
        assert deduped[0]["finding_type"] == "known_vuln"

    def test_does_not_mutate_original(self):
        known_vulns = [{"threat_id": "THREAT-1", "title": "Same title", "file_path": "src/app.py"}]
        pr_vulns = [
            {
                "threat_id": "PR-1",
                "title": "Same title",
                "file_path": "src/app.py",
                "finding_type": "unknown",
            }
        ]
        dedupe_pr_vulns(pr_vulns, known_vulns)
        # Original should NOT be mutated
        assert pr_vulns[0]["finding_type"] == "unknown"

    def test_missing_finding_type_treated_as_unknown(self):
        """If finding_type is missing (empty string after normalization), it should be treated as unknown and changed."""
        known_vulns = [{"threat_id": "THREAT-1", "title": "Same title", "file_path": "src/app.py"}]
        pr_vulns = [{"threat_id": "PR-1", "title": "Same title", "file_path": "src/app.py"}]
        deduped = dedupe_pr_vulns(pr_vulns, known_vulns)
        assert deduped[0]["finding_type"] == "known_vuln"

    def test_basename_collision_different_directories_not_marked_known(self):
        """Shared basename should not dedupe across different directories."""
        known_vulns = [
            {
                "threat_id": "THREAT-1",
                "title": "Command injection in handler",
                "file_path": "services/api/handler.py",
            }
        ]
        pr_vulns = [
            {
                "threat_id": "PR-1",
                "title": "Command injection in handler",
                "file_path": "services/web/handler.py",
                "finding_type": "unknown",
            }
        ]
        deduped = dedupe_pr_vulns(pr_vulns, known_vulns)
        assert deduped[0]["finding_type"] == "unknown"


class TestLoadPrVulnerabilitiesArtifact:
    """Tests for load_pr_vulnerabilities_artifact."""

    def test_file_not_found_returns_empty_with_error(self, tmp_path):
        missing = tmp_path / "PR_VULNERABILITIES.json"
        console = Console(quiet=True)
        result, error = load_pr_vulnerabilities_artifact(missing, console)
        assert result == []
        assert error is not None
        assert "was not produced" in error

    def test_read_error_returns_empty_with_error(self, tmp_path):
        bad_path = tmp_path / "PR_VULNERABILITIES.json"
        bad_path.mkdir()  # directory, not a file â€” read_text will raise OSError
        console = Console(quiet=True)
        result, error = load_pr_vulnerabilities_artifact(bad_path, console)
        assert result == []
        assert error is not None
        assert "Failed to read" in error

    def test_invalid_json_returns_empty_with_error(self, tmp_path):
        path = tmp_path / "PR_VULNERABILITIES.json"
        path.write_text("{not valid json", encoding="utf-8")
        console = Console(quiet=True)
        result, error = load_pr_vulnerabilities_artifact(path, console)
        assert result == []
        assert error is not None
        assert "Failed to parse" in error

    def test_non_list_json_returns_empty_with_error(self, tmp_path):
        path = tmp_path / "PR_VULNERABILITIES.json"
        path.write_text('{"key": "value"}', encoding="utf-8")
        console = Console(quiet=True)
        result, error = load_pr_vulnerabilities_artifact(path, console)
        assert result == []
        assert error is not None
        assert "not a JSON array" in error

    def test_valid_json_list_returns_findings(self, tmp_path):
        findings = [{"threat_id": "PR-1", "title": "SQLi"}, {"threat_id": "PR-2", "title": "XSS"}]
        path = tmp_path / "PR_VULNERABILITIES.json"
        path.write_text(json.dumps(findings), encoding="utf-8")
        console = Console(quiet=True)
        result, error = load_pr_vulnerabilities_artifact(path, console)
        assert error is None
        assert len(result) == 2
        assert result[0]["threat_id"] == "PR-1"

    def test_non_dict_entries_filtered(self, tmp_path):
        data = [{"threat_id": "PR-1"}, "not a dict", 42, None, {"threat_id": "PR-2"}]
        path = tmp_path / "PR_VULNERABILITIES.json"
        path.write_text(json.dumps(data), encoding="utf-8")
        console = Console(quiet=True)
        result, error = load_pr_vulnerabilities_artifact(path, console)
        assert error is None
        assert len(result) == 2

    def test_normalization_applied_when_needed(self, tmp_path):
        path = tmp_path / "PR_VULNERABILITIES.json"
        # Wrapped format that fix_pr_vulnerabilities_json should normalize
        path.write_text('{"vulnerabilities": [{"threat_id": "PR-1"}]}', encoding="utf-8")
        console = Console(quiet=True)
        result, error = load_pr_vulnerabilities_artifact(path, console)
        assert error is None
        assert len(result) == 1
        assert result[0]["threat_id"] == "PR-1"

    def test_fallback_to_raw_on_fixed_parse_failure(self, tmp_path):
        """When fix_pr_vulnerabilities_json produces invalid JSON but raw is valid."""
        valid_json = json.dumps([{"threat_id": "PR-1"}])
        path = tmp_path / "PR_VULNERABILITIES.json"
        path.write_text(valid_json, encoding="utf-8")
        console = Console(quiet=True)
        with patch(
            "securevibes.scanner.pr_review_merge.fix_pr_vulnerabilities_json",
            return_value=("{broken", True),
        ):
            result, error = load_pr_vulnerabilities_artifact(path, console)
        assert error is None
        assert len(result) == 1

    def test_empty_list_returns_empty_no_error(self, tmp_path):
        path = tmp_path / "PR_VULNERABILITIES.json"
        path.write_text("[]", encoding="utf-8")
        console = Console(quiet=True)
        result, error = load_pr_vulnerabilities_artifact(path, console)
        assert error is None
        assert result == []


class TestProofScore:
    """Tests for _proof_score (extracted merge helper)."""

    def test_empty_entry_returns_zero(self):
        assert _proof_score({}) == 0

    def test_exploit_primitive_term_scores_4(self):
        entry = {"title": "option injection in builder", "description": "", "evidence": ""}
        assert _proof_score(entry) >= 4

    def test_cwe_88_scores_4(self):
        entry = {"cwe_id": "CWE-88", "title": "issue", "description": ""}
        assert _proof_score(entry) >= 4

    def test_cwe_78_option_injection_bonus_scores_2(self):
        base_entry = {
            "title": "argv option injection issue",
            "description": "command builder accepts untrusted argv",
            "attack_scenario": "1) attacker controls argv\n2) command executes",
            "evidence": "src/runner.py:42 -> exec",
            "cwe_id": "CWE-79",
        }
        cwe_78_entry = dict(base_entry, cwe_id="CWE-78")
        assert _proof_score(cwe_78_entry) == _proof_score(base_entry) + 2

    def test_concrete_payload_in_scenario_scores_3(self):
        entry = {
            "attack_scenario": "Attacker supplies -o ProxyCommand=payload as host",
            "title": "injection",
        }
        assert _proof_score(entry) >= 3

    def test_file_path_and_line_each_add_1(self):
        base = _proof_score({"title": "x"})
        with_path = _proof_score({"title": "x", "file_path": "src/app.py"})
        with_both = _proof_score({"title": "x", "file_path": "src/app.py", "line_number": 42})
        assert with_path == base + 1
        assert with_both == base + 2

    def test_step_markers_add_1(self):
        base = _proof_score({"title": "x"})
        with_steps = _proof_score({"title": "x", "attack_scenario": "1) do A\n2) do B"})
        assert with_steps == base + 1

    def test_evidence_flow_arrow_adds_1(self):
        base = _proof_score({"title": "x"})
        with_flow = _proof_score({"title": "x", "evidence": "src/a.py:42 -> exec"})
        assert with_flow == base + 1

    def test_missing_separator_adds_2(self):
        base = _proof_score({"title": "x"})
        with_separator = _proof_score({"title": "missing -- separator", "description": "x"})
        # "missing --" also matches EXPLOIT_PRIMITIVE_TERMS (+4), so total delta is 6
        assert with_separator == base + 6

    def test_full_high_quality_finding(self):
        entry = {
            "title": "option injection via unsanitized host",
            "description": "missing -- separator allows option injection",
            "cwe_id": "CWE-88",
            "file_path": "src/ssh.py",
            "line_number": 42,
            "attack_scenario": "1) Attacker supplies -o ProxyCommand=payload\n2) ssh executes",
            "evidence": "src/ssh.py:42 -> exec without separator",
        }
        # CWE-88(4) + exploit_primitive(4) + payload(3) + missing --(2) + steps(1)
        # + file_path(1) + line(1) + evidence_flow(1) = 17
        score = _proof_score(entry)
        assert score >= 15  # high-evidence finding


class TestSpeculationPenalty:
    """Tests for _speculation_penalty (extracted merge helper)."""

    def test_clean_entry_returns_zero(self):
        entry = {
            "title": "SQL injection in query builder",
            "description": "Unsanitized input concatenated into query",
            "evidence": "db.py:10 -> execute",
        }
        assert _speculation_penalty(entry) == 0

    def test_single_speculative_term_returns_1(self):
        entry = {"title": "Potential injection", "description": ""}
        assert _speculation_penalty(entry) == 1

    def test_multiple_speculative_terms_accumulate(self):
        entry = {
            "title": "potential issue",
            "description": "this could lead to a hypothetical bypass",
        }
        penalty = _speculation_penalty(entry)
        assert penalty >= 3  # "potential", "could", "hypothetical"

    def test_hardening_term_adds_1(self):
        entry = {"title": "defense-in-depth recommendation", "description": "hardening"}
        penalty = _speculation_penalty(entry)
        # HARDENING_TERMS uses `any()` so only adds 1 regardless of how many terms match
        assert penalty == 1

    def test_capped_at_6(self):
        entry = {
            "title": "potential possible hypothetical future edge case",
            "description": "could might may warrant defense-in-depth hardening",
            "attack_scenario": "if bypass exists, testing needed",
        }
        assert _speculation_penalty(entry) == 6

    def test_multi_word_term_matched(self):
        entry = {"title": "issue", "description": "if bypass exists then exploit"}
        assert _speculation_penalty(entry) >= 1

    def test_single_word_term_requires_word_boundary(self):
        entry = {"title": "computation", "description": ""}  # "could" not present as word
        assert _speculation_penalty(entry) == 0


class TestSameChain:
    """Tests for _same_chain (extracted merge helper)."""

    def _make_finding(self, **overrides):
        base = {
            "title": "Option injection in build_ssh_command",
            "description": "Unsanitized host allows injection",
            "severity": "high",
            "file_path": "src/ssh_client.py",
            "line_number": 42,
            "cwe_id": "CWE-88",
            "finding_type": "new_threat",
            "attack_scenario": "1) Inject -o ProxyCommand\n2) Execute",
            "evidence": "src/ssh_client.py:42 -> exec",
        }
        base.update(overrides)
        return base

    def test_same_file_close_lines_similar_tokens_matches(self):
        a = self._make_finding(line_number=42)
        b = self._make_finding(line_number=44)
        assert _same_chain(a, b) is True

    def test_same_file_distant_lines_different_chains(self):
        a = self._make_finding(line_number=42)
        b = self._make_finding(
            line_number=500,
            title="Completely different XSS vulnerability",
            description="Unrelated issue in template rendering",
            cwe_id="CWE-79",
            attack_scenario="XSS via template",
            evidence="template.py:500 -> render",
        )
        assert _same_chain(a, b) is False

    def test_missing_path_returns_false(self):
        a = self._make_finding(file_path="")
        b = self._make_finding()
        assert _same_chain(a, b) is False

    def test_both_missing_paths_returns_false(self):
        a = self._make_finding(file_path="")
        b = self._make_finding(file_path="")
        assert _same_chain(a, b) is False

    def test_different_files_different_cwes_returns_false(self):
        a = self._make_finding(file_path="src/a.py", cwe_id="CWE-88")
        b = self._make_finding(file_path="src/b.py", cwe_id="CWE-79")
        assert _same_chain(a, b) is False

    def test_same_directory_same_cwe_high_similarity_matches(self):
        a = self._make_finding(
            file_path="src/handlers/ssh.py",
            line_number=10,
            title="Option injection in transport helper",
            description="Unsanitized host reaches argv in transport helper",
        )
        b = self._make_finding(
            file_path="src/handlers/sftp.py",
            line_number=20,
            title="Option injection in transport helper",
            description="Unsanitized host reaches argv in transport helper",
        )
        assert _same_chain(a, b) is True

    def test_same_file_far_apart_similar_text_does_not_match(self):
        a = self._make_finding(
            line_number=20,
            title="Option injection in transport helper",
            description="Unsanitized host reaches argv in transport helper",
        )
        b = self._make_finding(
            line_number=300,
            title="Option injection in transport helper",
            description="Unsanitized host reaches argv in transport helper",
        )
        assert _same_chain(a, b) is False

    def test_high_title_similarity_same_file_matches(self):
        a = self._make_finding(title="SQL injection in user query")
        b = self._make_finding(title="SQL injection in user query builder", line_number=100)
        assert _same_chain(a, b) is True

    def test_cwe78_88_close_lines_low_similarity_matches(self):
        """CWE-78 and CWE-88 pair within close line gap uses relaxed threshold."""
        a = self._make_finding(
            cwe_id="CWE-78",
            title="Command injection via host",
            description="different description A",
            attack_scenario="scenario A",
            evidence="evidence A",
        )
        b = self._make_finding(
            cwe_id="CWE-88",
            line_number=44,
            title="Option injection via host",
            description="different description B",
            attack_scenario="scenario B",
            evidence="evidence B",
        )
        assert _same_chain(a, b) is True


class TestSameSubchainFamily:
    """Tests for _same_subchain_family (extracted merge helper)."""

    def _make_finding(self, **overrides):
        base = {
            "title": "Option injection in build_ssh_command",
            "description": "Unsanitized host allows injection",
            "severity": "high",
            "file_path": "src/ssh_client.py",
            "line_number": 42,
            "cwe_id": "CWE-88",
            "finding_type": "new_threat",
            "attack_scenario": "1) Inject -o ProxyCommand\n2) Execute",
            "evidence": "src/ssh_client.py:42 -> exec",
        }
        base.update(overrides)
        return base

    def test_different_files_returns_false(self):
        a = self._make_finding(file_path="src/a.py")
        b = self._make_finding(file_path="src/b.py")
        assert _same_subchain_family(a, b) is False

    def test_missing_path_returns_false(self):
        a = self._make_finding(file_path="")
        b = self._make_finding()
        assert _same_subchain_family(a, b) is False

    def test_line_gap_beyond_threshold_returns_false(self):
        a = self._make_finding(line_number=10)
        b = self._make_finding(line_number=100)  # gap = 90 > MAX_LINE_GAP_SUBCHAIN (40)
        assert _same_subchain_family(a, b) is False

    def test_same_cwe_close_lines_matches(self):
        a = self._make_finding(line_number=42)
        b = self._make_finding(line_number=50)
        assert _same_subchain_family(a, b) is True

    def test_different_cwes_non_enabler_returns_false(self):
        a = self._make_finding(cwe_id="CWE-88", finding_type="new_threat")
        b = self._make_finding(cwe_id="CWE-79", line_number=44, finding_type="new_threat")
        assert _same_subchain_family(a, b) is False

    def test_same_cwe_shared_anchor_matches(self):
        """Shared sink anchor with same CWE family should match (line 776-777)."""
        a = self._make_finding(
            evidence="src/ssh_client.py:42 -> lib/exec.py:10",
        )
        b = self._make_finding(
            line_number=45,
            evidence="src/ssh_client.py:45 -> lib/exec.py:10",
        )
        assert _same_subchain_family(a, b) is True

    def test_same_cwe_shared_locations_matches(self):
        """Same CWE + shared referenced locations should match (line 778-785)."""
        a = self._make_finding(
            evidence="src/ssh_client.py:42 -> lib/sanitizer.py:20 -> lib/exec.py:10",
        )
        b = self._make_finding(
            line_number=45,
            evidence="src/ssh_client.py:45 -> lib/sanitizer.py:20 -> lib/runner.py:5",
        )
        assert _same_subchain_family(a, b) is True

    def test_end_to_end_variant_self_anchor_asymmetry_matches(self):
        """End-to-end variant with asymmetric self-anchoring should match (line 787-793)."""
        a = self._make_finding(
            title="Command injection exec sink",
            description="attacker input reaches exec call",
            evidence="src/ssh_client.py:42 -> exec shell command",
            attack_scenario="1) inject payload\n2) reach exec\n3) execute",
            finding_type="new_threat",
        )
        b = self._make_finding(
            line_number=45,
            title="Option injection build_ssh_command",
            description="unsanitized host",
            evidence="src/ssh_client.py:45",
            attack_scenario="inject option",
            finding_type="new_threat",
        )
        assert _same_subchain_family(a, b) is True

    def test_enabler_pair_shared_anchor_matches(self):
        """Enabler pair with shared anchor across CWE families should match (line 795-797)."""
        a = self._make_finding(
            cwe_id="CWE-88",
            finding_type="threat_enabler",
            evidence="src/ssh_client.py:42 -> lib/exec.py:10",
        )
        b = self._make_finding(
            cwe_id="CWE-79",
            line_number=44,
            finding_type="new_threat",
            evidence="src/ssh_client.py:44 -> lib/exec.py:10",
        )
        assert _same_subchain_family(a, b) is True

    def test_enabler_pair_shared_locations_matches(self):
        """Enabler pair with shared locations and sufficient token similarity (line 798-799)."""
        a = self._make_finding(
            cwe_id="CWE-88",
            finding_type="threat_enabler",
            title="Option injection in build_ssh_command allows bypass",
            description="Unsanitized host allows option injection",
            evidence="src/ssh_client.py:42 -> lib/sanitizer.py:20",
        )
        b = self._make_finding(
            cwe_id="CWE-79",
            line_number=44,
            finding_type="mitigation_removal",
            title="Option injection in build_ssh_command enables script injection",
            description="Unsanitized host allows option injection",
            evidence="src/ssh_client.py:44 -> lib/sanitizer.py:20",
        )
        assert _same_subchain_family(a, b) is True

    def test_enabler_e2e_self_anchor_asymmetry_matches(self):
        """Enabler pair with end-to-end variant and self-anchor asymmetry (line 800-804)."""
        a = self._make_finding(
            cwe_id="CWE-88",
            finding_type="threat_enabler",
            title="Option injection in build_ssh_command exec sink",
            description="attacker input reaches exec call through ssh command builder",
            evidence="src/ssh_client.py:42 -> exec shell command",
            attack_scenario="1) inject payload\n2) reach exec\n3) execute",
        )
        b = self._make_finding(
            cwe_id="CWE-79",
            line_number=44,
            finding_type="mitigation_removal",
            title="Option injection in build_ssh_command exec sink",
            description="attacker input reaches exec call through ssh command builder",
            evidence="src/ssh_client.py:44",
            attack_scenario="inject option",
        )
        assert _same_subchain_family(a, b) is True


class TestEntryQuality:
    """Tests for _entry_quality (extracted merge helper)."""

    def test_higher_severity_ranks_higher(self):
        low = _entry_quality({"severity": "low", "title": "x"})
        high = _entry_quality({"severity": "high", "title": "x"})
        assert high > low

    def test_higher_finding_type_ranks_higher(self):
        unknown = _entry_quality({"finding_type": "unknown", "title": "x"})
        regression = _entry_quality({"finding_type": "regression", "title": "x"})
        assert regression > unknown

    def test_chain_support_boosts_quality(self):
        entry = {
            "title": "injection",
            "severity": "high",
            "cwe_id": "CWE-88",
            "file_path": "src/a.py",
        }
        from securevibes.scanner.chain_analysis import build_chain_family_identity

        family_id = build_chain_family_identity(entry)
        without_support = _entry_quality(entry)
        with_support = _entry_quality(entry, chain_support_counts={family_id: 3})
        assert with_support.chain_support > without_support.chain_support

    def test_contradiction_penalty_applied(self):
        entry = {"title": "x", "severity": "high", "cwe_id": "CWE-88", "file_path": "a.py"}
        from securevibes.scanner.chain_analysis import build_chain_family_identity

        family_id = build_chain_family_identity(entry)
        quality = _entry_quality(
            entry,
            chain_support_counts={family_id: 1},
            total_attempts=3,
        )
        # contradiction_penalty = -(3 - 1) = -2
        assert quality.contradiction_penalty == -2

    def test_no_contradiction_when_no_support(self):
        quality = _entry_quality({"title": "x"}, total_attempts=3)
        assert quality.contradiction_penalty == 0

    def test_evidence_length_capped_at_4000(self):
        entry = {"title": "x", "evidence": "a" * 5000}
        quality = _entry_quality(entry)
        assert quality.evidence_length == 4000


class TestFindingTokensAndSimilarity:
    """Tests for _finding_tokens and _token_similarity."""

    def test_empty_entry_returns_empty_set(self):
        assert _finding_tokens({}) == set()

    def test_extracts_tokens_from_fields(self):
        entry = {"title": "SQL injection in query builder", "description": "user input"}
        tokens = _finding_tokens(entry)
        assert "injection" in tokens
        assert "query" in tokens
        assert "builder" in tokens

    def test_short_tokens_excluded(self):
        entry = {"title": "XSS in app"}
        tokens = _finding_tokens(entry)
        assert "xss" not in tokens  # len < 4
        assert "app" not in tokens  # len < 4

    def test_stopwords_excluded(self):
        entry = {"title": "vulnerability through code changes"}
        tokens = _finding_tokens(entry)
        assert "vulnerability" not in tokens  # in CHAIN_STOPWORDS
        assert "through" not in tokens

    def test_similarity_identical_sets(self):
        s = {"injection", "query", "builder"}
        assert _token_similarity(s, s) == 1.0

    def test_similarity_disjoint_sets(self):
        a = {"injection", "query"}
        b = {"template", "render"}
        assert _token_similarity(a, b) == 0.0

    def test_similarity_partial_overlap(self):
        a = {"injection", "query", "builder"}
        b = {"injection", "template", "render"}
        sim = _token_similarity(a, b)
        assert 0.0 < sim < 1.0
        assert sim == 1.0 / 5.0  # 1 overlap / 5 union

    def test_similarity_empty_set(self):
        assert _token_similarity(set(), {"x"}) == 0.0
        assert _token_similarity({"x"}, set()) == 0.0


class TestChainRole:
    """Tests for _chain_role (extracted merge helper)."""

    def test_end_to_end_with_flow_arrow_and_source_and_sink(self):
        entry = {
            "title": "Command injection",
            "evidence": "attacker input -> exec shell command",
            "attack_scenario": "Remote user sends payload",
        }
        assert _chain_role(entry) == "end_to_end"

    def test_step_level_without_evidence(self):
        entry = {"title": "Missing validation", "description": "Input not checked"}
        assert _chain_role(entry) == "step_level"

    def test_end_to_end_with_multi_location_and_steps_and_sink(self):
        entry = {
            "title": "exec issue",
            "description": "the exec sink is reached",
            "attack_scenario": "1) entry point\n2) transform\n3) exec call",
            "evidence": "src/a.py:10 and src/b.py:20 are involved",
        }
        assert _chain_role(entry) == "end_to_end"


class TestHasConcreteChainStructure:
    """Tests for _has_concrete_chain_structure (extracted merge helper)."""

    def test_true_with_path_line_flow_arrow(self):
        entry = {
            "file_path": "src/app.py",
            "line_number": 42,
            "evidence": "src/app.py:42 -> exec",
            "attack_scenario": "1) input\n2) exec",
        }
        assert _has_concrete_chain_structure(entry) is True

    def test_false_without_file_path(self):
        entry = {
            "line_number": 42,
            "evidence": "-> exec",
            "attack_scenario": "1) do\n2) run",
        }
        assert _has_concrete_chain_structure(entry) is False

    def test_false_without_line_number(self):
        entry = {
            "file_path": "src/app.py",
            "evidence": "-> exec",
            "attack_scenario": "1) do\n2) run",
        }
        assert _has_concrete_chain_structure(entry) is False

    def test_false_without_flow_markers(self):
        entry = {
            "file_path": "src/app.py",
            "line_number": 42,
            "evidence": "just some text",
            "attack_scenario": "does something",
        }
        assert _has_concrete_chain_structure(entry) is False


class TestMergePrAttemptFindingsDeep:
    """Deeper merge tests with precise expected outcomes."""

    def _make_finding(self, **overrides):
        base = {
            "threat_id": "PR-1",
            "title": "Option injection in build_ssh_command",
            "description": "Unsanitized host param allows option injection via missing --",
            "severity": "high",
            "file_path": "src/ssh_client.py",
            "line_number": 42,
            "cwe_id": "CWE-88",
            "finding_type": "new_threat",
            "attack_scenario": "1) Attacker supplies -o ProxyCommand=payload as host\n2) ssh executes",
            "evidence": "src/ssh_client.py:42 -> exec without -- separator",
        }
        base.update(overrides)
        return base

    def test_identical_findings_merge_to_one(self):
        finding = self._make_finding()
        result = merge_pr_attempt_findings([finding, dict(finding)])
        assert len(result) == 1

    def test_same_chain_different_quality_keeps_better(self):
        weak = self._make_finding(
            threat_id="PR-1",
            evidence="maybe an issue",
            attack_scenario="could be exploitable",
        )
        strong = self._make_finding(
            threat_id="PR-2",
            evidence="src/ssh_client.py:42 -> exec without -- separator",
            attack_scenario="1) Attacker supplies -o ProxyCommand=payload\n2) ssh executes",
        )
        stats = {}
        result = merge_pr_attempt_findings([weak, strong], merge_stats=stats)
        assert len(result) == 1
        # The strong finding should be the survivor
        assert result[0]["threat_id"] == "PR-2"

    def test_distinct_chains_both_retained(self):
        ssh_finding = self._make_finding(
            threat_id="PR-1",
            title="Option injection in ssh builder",
            file_path="src/ssh.py",
            cwe_id="CWE-88",
        )
        xss_finding = self._make_finding(
            threat_id="PR-2",
            title="XSS via template rendering",
            description="User input rendered in HTML without escaping",
            file_path="src/views.py",
            line_number=100,
            cwe_id="CWE-79",
            attack_scenario="1) User submits <script> tag\n2) Rendered in page",
            evidence="src/views.py:100 -> render_template",
        )
        result = merge_pr_attempt_findings([ssh_finding, xss_finding])
        assert len(result) == 2
        threat_ids = {r["threat_id"] for r in result}
        assert threat_ids == {"PR-1", "PR-2"}

    def test_speculative_finding_dropped_when_strong_exists(self):
        strong = self._make_finding(
            threat_id="PR-1",
            title="option injection via host",
            description="missing -- allows option injection",
            evidence="src/ssh_client.py:42 -> exec",
            attack_scenario="1) Attacker supplies -o ProxyCommand\n2) exec",
        )
        speculative = self._make_finding(
            threat_id="PR-2",
            title="potential future bypass could affect callers",
            description="hypothetical edge case if future code changes",
            file_path="src/other.py",
            line_number=200,
            cwe_id="CWE-79",
            evidence="might exist",
            attack_scenario="could happen",
        )
        result = merge_pr_attempt_findings([strong, speculative])
        # The speculative finding should be filtered by the strong-findings gate
        assert len(result) == 1
        assert result[0]["threat_id"] == "PR-1"

    def test_merge_stats_counts_are_precise(self):
        f1 = self._make_finding(threat_id="PR-1")
        f2 = self._make_finding(threat_id="PR-2", line_number=43)  # same chain
        f3 = self._make_finding(
            threat_id="PR-3",
            title="Different XSS issue",
            file_path="src/views.py",
            cwe_id="CWE-79",
            line_number=100,
            description="XSS via template",
            attack_scenario="1) inject script\n2) rendered",
            evidence="src/views.py:100 -> render",
        )
        stats = {}
        result = merge_pr_attempt_findings([f1, f2, f3], merge_stats=stats)
        assert len(result) == 2
        assert stats["input_count"] == 3
        # f1 and f2 merge in canonical pass, f3 is separate
        assert stats["canonical_count"] <= 3

    def test_secondary_guard_does_not_collapse_same_cwe_without_similarity(self):
        close_a = self._make_finding(
            threat_id="PR-A",
            title="Template context bleed enables script execution",
            description="raw html fragment appended into response body",
            file_path="src/views.py",
            line_number=50,
            cwe_id="CWE-79",
            attack_scenario="1) client submits crafted svg\n2) browser executes script",
            evidence="",
        )
        close_b = self._make_finding(
            threat_id="PR-B",
            title="JSONP callback override leaks profile data",
            description="callback parameter controls envelope function name",
            file_path="src/views.py",
            line_number=56,  # inside secondary guard proximity window
            cwe_id="CWE-79",
            attack_scenario="1) callback value supplied in query\n2) response leaks profile",
            evidence="",
        )

        result = merge_pr_attempt_findings([close_a, close_b])
        assert len(result) == 2
        assert {entry["threat_id"] for entry in result} == {"PR-A", "PR-B"}
