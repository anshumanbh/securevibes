"""Tests for scanner.pr_review_merge helpers."""

import json

from securevibes.models.issue import SecurityIssue, Severity
from securevibes.scanner.pr_review_merge import (
    _attempts_show_pr_disagreement,
    _build_pr_retry_focus_plan,
    _build_pr_review_retry_suffix,
    _build_vuln_match_keys,
    _extract_observed_pr_findings,
    _focus_area_label,
    _issues_from_pr_vulns,
    _merge_pr_attempt_findings,
    _normalize_finding_identity,
    _should_run_pr_verifier,
    dedupe_pr_vulns,
    filter_baseline_vulns,
)


# ---------------------------------------------------------------------------
# filter_baseline_vulns
# ---------------------------------------------------------------------------


class TestFilterBaselineVulns:
    """Tests for filter_baseline_vulns."""

    def test_excludes_pr_review_entries(self):
        known_vulns = [
            {"threat_id": "PR-001", "title": "Generated by PR review"},
            {"threat_id": "THREAT-1", "source": "pr_review", "title": "PR artifact"},
            {"threat_id": "THREAT-2", "finding_type": "regression", "title": "PR regression"},
            {"threat_id": "THREAT-3", "finding_type": "unknown", "title": "PR unknown"},
            {"threat_id": "THREAT-4", "title": "Baseline vuln"},
        ]
        baseline = filter_baseline_vulns(known_vulns)
        assert baseline == [{"threat_id": "THREAT-4", "title": "Baseline vuln"}]

    def test_empty_list_returns_empty(self):
        assert filter_baseline_vulns([]) == []

    def test_all_pr_entries_returns_empty(self):
        vulns = [
            {"threat_id": "PR-001", "title": "PR entry"},
            {"threat_id": "NEW-001", "title": "New entry"},
            {"source": "pr_review", "title": "Source-tagged"},
        ]
        assert filter_baseline_vulns(vulns) == []

    def test_all_baseline_entries_returned(self):
        vulns = [
            {"threat_id": "THREAT-1", "title": "Baseline 1"},
            {"threat_id": "THREAT-2", "title": "Baseline 2"},
        ]
        baseline = filter_baseline_vulns(vulns)
        assert len(baseline) == 2
        assert baseline == vulns

    def test_non_dict_entries_skipped(self):
        vulns = [
            "not a dict",
            42,
            None,
            {"threat_id": "THREAT-1", "title": "Valid baseline"},
        ]
        baseline = filter_baseline_vulns(vulns)
        assert len(baseline) == 1
        assert baseline[0]["threat_id"] == "THREAT-1"

    def test_new_prefix_excluded(self):
        vulns = [{"threat_id": "NEW-42", "title": "New threat"}]
        assert filter_baseline_vulns(vulns) == []

    def test_finding_type_case_insensitive(self):
        vulns = [
            {"threat_id": "THREAT-1", "finding_type": "REGRESSION", "title": "Upper case"},
            {"threat_id": "THREAT-2", "finding_type": " Unknown ", "title": "Whitespace"},
        ]
        assert filter_baseline_vulns(vulns) == []

    def test_mixed_baseline_and_pr(self):
        vulns = [
            {"threat_id": "THREAT-1", "title": "Baseline"},
            {"threat_id": "PR-10", "title": "PR"},
            {"threat_id": "THREAT-2", "title": "Baseline 2"},
            {"finding_type": "new_threat", "title": "PR threat"},
        ]
        baseline = filter_baseline_vulns(vulns)
        assert len(baseline) == 2
        assert baseline[0]["title"] == "Baseline"
        assert baseline[1]["title"] == "Baseline 2"


# ---------------------------------------------------------------------------
# _normalize_finding_identity
# ---------------------------------------------------------------------------


class TestNormalizeFindingIdentity:
    """Tests for _normalize_finding_identity."""

    def test_normal_string(self):
        assert _normalize_finding_identity("CommandInjection") == "commandinjection"

    def test_whitespace_stripped(self):
        assert _normalize_finding_identity("  Hello World  ") == "hello world"

    def test_non_string_returns_empty(self):
        assert _normalize_finding_identity(42) == ""
        assert _normalize_finding_identity(None) == ""
        assert _normalize_finding_identity([]) == ""
        assert _normalize_finding_identity({}) == ""

    def test_empty_string(self):
        assert _normalize_finding_identity("") == ""

    def test_already_lowercase(self):
        assert _normalize_finding_identity("already lower") == "already lower"


# ---------------------------------------------------------------------------
# _build_vuln_match_keys
# ---------------------------------------------------------------------------


class TestBuildVulnMatchKeys:
    """Tests for _build_vuln_match_keys."""

    def test_with_path_and_title(self):
        vuln = {"title": "SQLi", "file_path": "src/app.py"}
        keys = _build_vuln_match_keys(vuln)
        assert len(keys) > 0
        # Should include basename key and full path key
        identities = {k[1] for k in keys}
        assert "sqli" in identities

    def test_with_threat_id_and_title(self):
        vuln = {"threat_id": "THREAT-1", "title": "XSS", "file_path": "src/views.py"}
        keys = _build_vuln_match_keys(vuln)
        identities = {k[1] for k in keys}
        assert "threat-1" in identities
        assert "xss" in identities

    def test_without_path(self):
        vuln = {"title": "Issue"}
        keys = _build_vuln_match_keys(vuln)
        # Without file_path, path is empty string
        paths = {k[0] for k in keys}
        assert "" in paths

    def test_no_identities_returns_empty(self):
        vuln = {"file_path": "src/app.py"}
        keys = _build_vuln_match_keys(vuln)
        assert keys == set()

    def test_non_string_identities_returns_empty(self):
        vuln = {"threat_id": 123, "title": None}
        keys = _build_vuln_match_keys(vuln)
        assert keys == set()

    def test_basename_included(self):
        vuln = {"title": "Bug", "file_path": "packages/core/src/handler.py"}
        keys = _build_vuln_match_keys(vuln)
        paths = {k[0] for k in keys}
        assert "handler.py" in paths


# ---------------------------------------------------------------------------
# _issues_from_pr_vulns
# ---------------------------------------------------------------------------


class TestIssuesFromPrVulns:
    """Tests for _issues_from_pr_vulns."""

    def test_valid_entry(self):
        vulns = [
            {
                "threat_id": "PR-1",
                "title": "SQL Injection",
                "description": "User input unsanitized",
                "severity": "high",
                "file_path": "src/db.py",
                "line_number": 42,
                "code_snippet": "query = f'SELECT * FROM {user_input}'",
                "cwe_id": "CWE-89",
                "recommendation": "Use parameterized queries",
                "finding_type": "new_threat",
                "attack_scenario": "Attacker submits malicious input",
                "evidence": "No input validation found",
            }
        ]
        issues = _issues_from_pr_vulns(vulns)
        assert len(issues) == 1
        issue = issues[0]
        assert isinstance(issue, SecurityIssue)
        assert issue.id == "PR-1"
        assert issue.title == "SQL Injection"
        assert issue.severity == Severity.HIGH
        assert issue.file_path == "src/db.py"
        assert issue.line_number == 42
        assert issue.cwe_id == "CWE-89"
        assert issue.finding_type == "new_threat"

    def test_missing_fields_use_defaults(self):
        vulns = [{}]
        issues = _issues_from_pr_vulns(vulns)
        assert len(issues) == 1
        issue = issues[0]
        assert issue.id == "UNKNOWN"
        assert issue.title == ""
        assert issue.severity == Severity.MEDIUM
        assert issue.line_number == 0

    def test_invalid_severity_defaults_to_medium(self):
        vulns = [{"severity": "super_critical"}]
        issues = _issues_from_pr_vulns(vulns)
        assert issues[0].severity == Severity.MEDIUM

    def test_non_dict_entries_skipped(self):
        vulns = ["not a dict", 42, None, {"title": "Valid"}]
        issues = _issues_from_pr_vulns(vulns)
        assert len(issues) == 1
        assert issues[0].title == "Valid"

    def test_invalid_line_number_defaults_to_zero(self):
        vulns = [{"line_number": "not_a_number"}]
        issues = _issues_from_pr_vulns(vulns)
        assert issues[0].line_number == 0

    def test_none_line_number_defaults_to_zero(self):
        vulns = [{"line_number": None}]
        issues = _issues_from_pr_vulns(vulns)
        assert issues[0].line_number == 0

    def test_empty_list(self):
        assert _issues_from_pr_vulns([]) == []

    def test_multiple_entries(self):
        vulns = [
            {"threat_id": "PR-1", "title": "Issue 1"},
            {"threat_id": "PR-2", "title": "Issue 2"},
        ]
        issues = _issues_from_pr_vulns(vulns)
        assert len(issues) == 2
        assert issues[0].id == "PR-1"
        assert issues[1].id == "PR-2"


# ---------------------------------------------------------------------------
# _focus_area_label
# ---------------------------------------------------------------------------


class TestFocusAreaLabel:
    """Tests for _focus_area_label."""

    def test_known_command_option(self):
        assert _focus_area_label("command_option") == "COMMAND/OPTION INJECTION CHAINS"

    def test_known_path_exfiltration(self):
        assert _focus_area_label("path_exfiltration") == "PATH + FILE EXFILTRATION CHAINS"

    def test_known_auth_privileged(self):
        assert _focus_area_label("auth_privileged") == "AUTH + PRIVILEGED OPERATION CHAINING"

    def test_unknown_label_returns_input(self):
        assert _focus_area_label("something_else") == "something_else"

    def test_empty_string(self):
        assert _focus_area_label("") == ""


# ---------------------------------------------------------------------------
# _build_pr_retry_focus_plan
# ---------------------------------------------------------------------------


class TestBuildPrRetryFocusPlan:
    """Tests for _build_pr_retry_focus_plan."""

    def test_attempt_count_1_returns_empty(self):
        result = _build_pr_retry_focus_plan(
            1,
            command_builder_signals=True,
            path_parser_signals=True,
            auth_privilege_signals=True,
        )
        assert result == []

    def test_attempt_count_0_returns_empty(self):
        result = _build_pr_retry_focus_plan(
            0,
            command_builder_signals=True,
            path_parser_signals=True,
            auth_privilege_signals=True,
        )
        assert result == []

    def test_attempt_count_3_with_all_signals(self):
        result = _build_pr_retry_focus_plan(
            3,
            command_builder_signals=True,
            path_parser_signals=True,
            auth_privilege_signals=True,
        )
        # 3 attempts => 2 retries
        assert len(result) == 2
        assert result[0] == "command_option"
        assert result[1] == "path_exfiltration"

    def test_attempt_count_3_no_signals(self):
        result = _build_pr_retry_focus_plan(
            3,
            command_builder_signals=False,
            path_parser_signals=False,
            auth_privilege_signals=False,
        )
        # Falls back to default order
        assert len(result) == 2
        assert result[0] == "command_option"
        assert result[1] == "path_exfiltration"

    def test_attempt_count_2_with_path_signal_only(self):
        result = _build_pr_retry_focus_plan(
            2,
            command_builder_signals=False,
            path_parser_signals=True,
            auth_privilege_signals=False,
        )
        # 2 attempts => 1 retry
        assert len(result) == 1
        assert result[0] == "path_exfiltration"

    def test_wraps_around_with_many_retries(self):
        result = _build_pr_retry_focus_plan(
            5,
            command_builder_signals=False,
            path_parser_signals=False,
            auth_privilege_signals=False,
        )
        # 5 attempts => 4 retries, cycles through 3 focus areas
        assert len(result) == 4
        assert result[3] == result[0]  # wraps around


# ---------------------------------------------------------------------------
# _attempts_show_pr_disagreement
# ---------------------------------------------------------------------------


class TestAttemptsShowPrDisagreement:
    """Tests for _attempts_show_pr_disagreement."""

    def test_single_attempt_returns_false(self):
        assert _attempts_show_pr_disagreement([5]) is False

    def test_empty_list_returns_false(self):
        assert _attempts_show_pr_disagreement([]) is False

    def test_all_same_nonzero_returns_false(self):
        assert _attempts_show_pr_disagreement([3, 3, 3]) is False

    def test_all_zero_returns_false(self):
        assert _attempts_show_pr_disagreement([0, 0, 0]) is False

    def test_some_zero_some_nonzero_returns_true(self):
        assert _attempts_show_pr_disagreement([3, 0, 3]) is True

    def test_all_different_nonzero_returns_true(self):
        assert _attempts_show_pr_disagreement([1, 2, 3]) is True

    def test_two_attempts_same(self):
        assert _attempts_show_pr_disagreement([2, 2]) is False

    def test_two_attempts_different(self):
        assert _attempts_show_pr_disagreement([2, 5]) is True

    def test_one_zero_one_nonzero(self):
        assert _attempts_show_pr_disagreement([0, 5]) is True


# ---------------------------------------------------------------------------
# _should_run_pr_verifier
# ---------------------------------------------------------------------------


class TestShouldRunPrVerifier:
    """Tests for _should_run_pr_verifier."""

    def test_true_when_both_conditions_met(self):
        assert _should_run_pr_verifier(has_findings=True, weak_consensus=True) is True

    def test_false_when_no_findings(self):
        assert _should_run_pr_verifier(has_findings=False, weak_consensus=True) is False

    def test_false_when_strong_consensus(self):
        assert _should_run_pr_verifier(has_findings=True, weak_consensus=False) is False

    def test_false_when_neither(self):
        assert _should_run_pr_verifier(has_findings=False, weak_consensus=False) is False


# ---------------------------------------------------------------------------
# _extract_observed_pr_findings
# ---------------------------------------------------------------------------


class TestExtractObservedPrFindings:
    """Tests for _extract_observed_pr_findings."""

    def test_none_observer_returns_empty(self):
        assert _extract_observed_pr_findings(None) == []

    def test_empty_dict_observer_returns_empty(self):
        assert _extract_observed_pr_findings({}) == []

    def test_empty_max_content_returns_empty(self):
        assert _extract_observed_pr_findings({"max_content": ""}) == []

    def test_whitespace_max_content_returns_empty(self):
        assert _extract_observed_pr_findings({"max_content": "   "}) == []

    def test_valid_json_list(self):
        findings = [{"title": "Issue 1"}, {"title": "Issue 2"}]
        observer = {"max_content": json.dumps(findings)}
        result = _extract_observed_pr_findings(observer)
        assert len(result) == 2
        assert result[0]["title"] == "Issue 1"

    def test_invalid_json_returns_empty(self):
        assert _extract_observed_pr_findings({"max_content": "not json {"}) == []

    def test_non_list_json_returns_empty(self):
        assert _extract_observed_pr_findings({"max_content": '{"key": "value"}'}) == []

    def test_non_dict_entries_filtered(self):
        observer = {"max_content": json.dumps([{"title": "Valid"}, "invalid", 42])}
        result = _extract_observed_pr_findings(observer)
        assert len(result) == 1
        assert result[0]["title"] == "Valid"

    def test_non_string_max_content_returns_empty(self):
        assert _extract_observed_pr_findings({"max_content": 12345}) == []


# ---------------------------------------------------------------------------
# _build_pr_review_retry_suffix
# ---------------------------------------------------------------------------


class TestBuildPrReviewRetrySuffix:
    """Tests for _build_pr_review_retry_suffix."""

    def test_basic_retry_contains_attempt_number(self):
        result = _build_pr_review_retry_suffix(2)
        assert "FOLLOW-UP ANALYSIS PASS 2" in result

    def test_default_focus_area_attempt_2(self):
        result = _build_pr_review_retry_suffix(2)
        # attempt_num==2 defaults to command_option focus
        assert "COMMAND/OPTION INJECTION CHAINS" in result

    def test_default_focus_area_attempt_3(self):
        result = _build_pr_review_retry_suffix(3)
        assert "PATH + FILE EXFILTRATION CHAINS" in result

    def test_default_focus_area_attempt_4(self):
        result = _build_pr_review_retry_suffix(4)
        assert "AUTH + PRIVILEGED OPERATION CHAINING" in result

    def test_explicit_focus_area_overrides_default(self):
        result = _build_pr_review_retry_suffix(2, focus_area="auth_privileged")
        assert "AUTH + PRIVILEGED OPERATION CHAINING" in result
        # Should NOT contain command_option default focus for attempt 2
        assert "FOCUS AREA: COMMAND/OPTION INJECTION CHAINS" not in result

    def test_command_builder_signals_hint(self):
        result = _build_pr_review_retry_suffix(2, command_builder_signals=True)
        assert "COMMAND-BUILDER DELTA DETECTED" in result

    def test_path_parser_signals_hint(self):
        result = _build_pr_review_retry_suffix(2, path_parser_signals=True)
        assert "PATH-PARSER DELTA DETECTED" in result

    def test_auth_privilege_signals_hint(self):
        result = _build_pr_review_retry_suffix(2, auth_privilege_signals=True)
        assert "AUTH/PRIVILEGE DELTA DETECTED" in result

    def test_candidate_summary_included(self):
        result = _build_pr_review_retry_suffix(
            2, candidate_summary="Chain 1: option injection in build_cmd"
        )
        assert "Chain 1: option injection in build_cmd" in result
        assert "PRIOR HIGH-IMPACT CHAIN CANDIDATES" in result
        assert "UNRESOLVED HYPOTHESIS DISPOSITION" in result

    def test_empty_candidate_summary_no_hint(self):
        result = _build_pr_review_retry_suffix(2, candidate_summary="")
        assert "PRIOR HIGH-IMPACT CHAIN CANDIDATES" not in result

    def test_whitespace_only_candidate_summary_no_hint(self):
        result = _build_pr_review_retry_suffix(2, candidate_summary="   ")
        assert "PRIOR HIGH-IMPACT CHAIN CANDIDATES" not in result

    def test_require_candidate_revalidation(self):
        result = _build_pr_review_retry_suffix(
            2, candidate_summary="something", require_candidate_revalidation=True
        )
        assert "CORE CHAIN REVALIDATION REQUIREMENT" in result

    def test_revalidation_without_candidate_summary(self):
        result = _build_pr_review_retry_suffix(2, require_candidate_revalidation=True)
        # Without candidate_summary, revalidation hint should still appear
        assert "CORE CHAIN REVALIDATION REQUIREMENT" in result


# ---------------------------------------------------------------------------
# _merge_pr_attempt_findings
# ---------------------------------------------------------------------------


class TestMergePrAttemptFindings:
    """Tests for _merge_pr_attempt_findings."""

    def test_empty_input_returns_empty(self):
        result = _merge_pr_attempt_findings([])
        assert result == []

    def test_empty_input_populates_merge_stats(self):
        stats = {}
        _merge_pr_attempt_findings([], merge_stats=stats)
        assert stats["input_count"] == 0
        assert stats["canonical_count"] == 0
        assert stats["final_count"] == 0
        assert stats["speculative_dropped"] == 0
        assert stats["subchain_collapsed"] == 0
        assert stats["low_support_dropped"] == 0
        assert stats["dropped_as_secondary_chain"] == 0
        assert stats["max_chain_support"] == 0

    def test_single_finding_retained(self):
        finding = {
            "threat_id": "PR-1",
            "title": "Option injection in build_ssh_command via unsanitized host",
            "description": "The host parameter is interpolated into the ssh command without validation",
            "severity": "high",
            "file_path": "src/ssh_client.py",
            "line_number": 42,
            "code_snippet": "cmd = f'ssh {host}'",
            "cwe_id": "CWE-88",
            "finding_type": "new_threat",
            "attack_scenario": "1) Attacker supplies -o ProxyCommand=... as host\n2) ssh executes attacker payload",
            "evidence": "src/ssh_client.py:42 -> ssh exec without -- separator",
        }
        result = _merge_pr_attempt_findings([finding])
        assert len(result) >= 1

    def test_duplicate_findings_merged(self):
        """Two findings with same path, same CWE, close line numbers, similar tokens should merge."""
        finding_1 = {
            "threat_id": "PR-1",
            "title": "Option injection in build_ssh_command",
            "description": "Unsanitized host param allows option injection",
            "severity": "high",
            "file_path": "src/ssh_client.py",
            "line_number": 42,
            "cwe_id": "CWE-88",
            "finding_type": "new_threat",
            "attack_scenario": "1) Attacker supplies -o ProxyCommand=... as host\n2) ssh exec",
            "evidence": "src/ssh_client.py:42 -> exec",
        }
        finding_2 = {
            "threat_id": "PR-2",
            "title": "Option injection in build_ssh_command via host param",
            "description": "Unsanitized host parameter enables option injection in ssh",
            "severity": "high",
            "file_path": "src/ssh_client.py",
            "line_number": 43,
            "cwe_id": "CWE-88",
            "finding_type": "new_threat",
            "attack_scenario": "1) Attacker supplies -o ProxyCommand=... as host\n2) ssh exec",
            "evidence": "src/ssh_client.py:42 -> exec flow",
        }
        stats = {}
        result = _merge_pr_attempt_findings([finding_1, finding_2], merge_stats=stats)
        # Should merge into one since they are about the same chain
        assert stats["input_count"] == 2
        assert len(result) <= 2  # merged or collapsed

    def test_merge_stats_populated(self):
        finding = {
            "threat_id": "PR-1",
            "title": "Test finding",
            "severity": "medium",
            "file_path": "src/app.py",
            "line_number": 10,
            "finding_type": "new_threat",
        }
        stats = {}
        _merge_pr_attempt_findings([finding], merge_stats=stats)
        assert "input_count" in stats
        assert stats["input_count"] == 1
        assert "canonical_count" in stats
        assert "final_count" in stats

    def test_non_dict_entries_filtered(self):
        vulns = ["not_a_dict", 42, {"threat_id": "PR-1", "title": "Valid"}]
        result = _merge_pr_attempt_findings(vulns)
        # Non-dict entries should be filtered out during normalization
        assert all(isinstance(r, dict) for r in result)

    def test_low_support_dropped_with_chain_counts(self):
        """Findings with low chain support should be dropped when others have high support."""
        high_support_finding = {
            "threat_id": "PR-1",
            "title": "Option injection in build_ssh_command via unsanitized host",
            "description": "Host parameter injection leads to arbitrary option injection",
            "severity": "high",
            "file_path": "src/ssh.py",
            "line_number": 42,
            "cwe_id": "CWE-88",
            "finding_type": "new_threat",
            "attack_scenario": "1) Attacker supplies -o ProxyCommand=payload as host\n2) ssh executes payload",
            "evidence": "src/ssh.py:42 -> ssh exec without -- separator",
        }
        low_support_finding = {
            "threat_id": "PR-2",
            "title": "Missing rate limit on login endpoint",
            "description": "No rate limiting",
            "severity": "medium",
            "file_path": "src/auth.py",
            "line_number": 100,
            "cwe_id": "CWE-307",
            "finding_type": "new_threat",
            "attack_scenario": "1) Attacker brute forces\n2) Auth bypassed",
            "evidence": "src/auth.py:100 -> flow to login handler",
        }
        from securevibes.scanner.chain_analysis import (
            build_chain_family_identity,
            build_chain_identity,
        )

        chain_support = {}
        for identity_fn in (build_chain_family_identity, build_chain_identity):
            key = identity_fn(high_support_finding)
            if key:
                chain_support[key] = 3
            key = identity_fn(low_support_finding)
            if key:
                chain_support[key] = 1

        stats = {}
        _merge_pr_attempt_findings(
            [high_support_finding, low_support_finding],
            merge_stats=stats,
            chain_support_counts=chain_support,
            total_attempts=3,
        )
        # The low support finding may be dropped
        assert stats["input_count"] == 2

    def test_max_chain_support_stat(self):
        finding = {
            "threat_id": "PR-1",
            "title": "Test",
            "severity": "high",
            "file_path": "a.py",
            "line_number": 1,
        }
        stats = {}
        chain_support = {"some_chain": 5}
        _merge_pr_attempt_findings(
            [finding],
            merge_stats=stats,
            chain_support_counts=chain_support,
            total_attempts=5,
        )
        assert stats["max_chain_support"] == 5

    def test_no_chain_support_counts_stat_zero(self):
        stats = {}
        _merge_pr_attempt_findings(
            [{"threat_id": "PR-1", "title": "Test"}],
            merge_stats=stats,
            chain_support_counts=None,
            total_attempts=0,
        )
        assert stats["max_chain_support"] == 0


# ---------------------------------------------------------------------------
# dedupe_pr_vulns
# ---------------------------------------------------------------------------


class TestDedupePrVulns:
    """Tests for dedupe_pr_vulns."""

    def test_marks_unknown_overlap_as_known_vuln(self):
        known_vulns = [
            {
                "threat_id": "THREAT-123",
                "title": "Command injection path",
                "file_path": "src/runner.py",
            }
        ]
        pr_vulns = [
            {
                "threat_id": "PR-999",
                "title": "Command injection path",
                "file_path": "src/runner.py",
                "finding_type": "unknown",
            }
        ]
        deduped = dedupe_pr_vulns(pr_vulns, known_vulns)
        assert len(deduped) == 1
        assert deduped[0]["finding_type"] == "known_vuln"

    def test_no_overlap_no_change(self):
        known_vulns = [
            {"threat_id": "THREAT-1", "title": "XSS in template", "file_path": "src/views.py"}
        ]
        pr_vulns = [
            {
                "threat_id": "PR-1",
                "title": "SQLi in query builder",
                "file_path": "src/db.py",
                "finding_type": "unknown",
            }
        ]
        deduped = dedupe_pr_vulns(pr_vulns, known_vulns)
        assert len(deduped) == 1
        assert deduped[0]["finding_type"] == "unknown"

    def test_non_unknown_finding_type_not_changed(self):
        """If finding_type is already set to something other than 'unknown', it should not be changed."""
        known_vulns = [{"threat_id": "THREAT-1", "title": "Same title", "file_path": "src/app.py"}]
        pr_vulns = [
            {
                "threat_id": "PR-1",
                "title": "Same title",
                "file_path": "src/app.py",
                "finding_type": "new_threat",
            }
        ]
        deduped = dedupe_pr_vulns(pr_vulns, known_vulns)
        assert len(deduped) == 1
        assert deduped[0]["finding_type"] == "new_threat"

    def test_empty_pr_vulns(self):
        deduped = dedupe_pr_vulns([], [{"threat_id": "T-1", "title": "Baseline"}])
        assert deduped == []

    def test_empty_known_vulns(self):
        pr_vulns = [{"threat_id": "PR-1", "title": "Issue", "finding_type": "unknown"}]
        deduped = dedupe_pr_vulns(pr_vulns, [])
        assert len(deduped) == 1
        assert deduped[0]["finding_type"] == "unknown"

    def test_non_dict_known_vulns_skipped(self):
        pr_vulns = [{"threat_id": "PR-1", "title": "Issue", "finding_type": "unknown"}]
        deduped = dedupe_pr_vulns(pr_vulns, ["not_a_dict", 42])
        assert len(deduped) == 1
        assert deduped[0]["finding_type"] == "unknown"

    def test_non_dict_pr_vulns_skipped(self):
        deduped = dedupe_pr_vulns(
            ["not_a_dict", {"threat_id": "PR-1", "title": "Valid"}],
            [{"threat_id": "T-1", "title": "Baseline"}],
        )
        assert len(deduped) == 1

    def test_threat_id_overlap_marks_as_known(self):
        """Overlap by threat_id identity match should mark as known_vuln."""
        known_vulns = [{"threat_id": "THREAT-1", "title": "Some vuln", "file_path": "src/app.py"}]
        pr_vulns = [
            {
                "threat_id": "THREAT-1",
                "title": "Different title",
                "file_path": "src/app.py",
                "finding_type": "unknown",
            }
        ]
        deduped = dedupe_pr_vulns(pr_vulns, known_vulns)
        assert deduped[0]["finding_type"] == "known_vuln"

    def test_does_not_mutate_original(self):
        known_vulns = [{"threat_id": "THREAT-1", "title": "Same title", "file_path": "src/app.py"}]
        pr_vulns = [
            {
                "threat_id": "PR-1",
                "title": "Same title",
                "file_path": "src/app.py",
                "finding_type": "unknown",
            }
        ]
        dedupe_pr_vulns(pr_vulns, known_vulns)
        # Original should NOT be mutated
        assert pr_vulns[0]["finding_type"] == "unknown"

    def test_missing_finding_type_treated_as_unknown(self):
        """If finding_type is missing (empty string after normalization), it should be treated as unknown and changed."""
        known_vulns = [{"threat_id": "THREAT-1", "title": "Same title", "file_path": "src/app.py"}]
        pr_vulns = [{"threat_id": "PR-1", "title": "Same title", "file_path": "src/app.py"}]
        deduped = dedupe_pr_vulns(pr_vulns, known_vulns)
        assert deduped[0]["finding_type"] == "known_vuln"
